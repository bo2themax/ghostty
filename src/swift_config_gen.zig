//! This program is used to generate Swift configuration types from the Zig
//! configuration file for Ghostty. This allows the macOS app to access
//! configuration options in a type-safe way.

const std = @import("std");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
const Config = @import("config/Config.zig");
const configpkg = @import("config.zig");

const log = std.log.scoped(.swift_config_gen);

/// Configuration fields to exclude from Swift generation (macOS-specific filtering)
const filtered_fields = [_][]const u8{
    "class",
    "x11-instance-name",
};

pub const GenerateError = error{
    OutOfMemory,
    WriteError,
    ParseError,
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer {
        const deinit_status = gpa.deinit();
        if (deinit_status == .leak) {
            log.err("memory leak detected", .{});
        }
    }
    const alloc = gpa.allocator();

    const stdout = std.io.getStdOut().writer();
    
    try generateSwiftHeader(stdout);
    genConfigFields(alloc, stdout) catch |err| {
        log.err("failed to generate config fields: {}", .{err});
        return err;
    };
    try generateSwiftFooter(stdout);
}

fn generateSwiftHeader(writer: anytype) !void {
    try writer.writeAll(
        \\// THIS FILE IS AUTO GENERATED
        \\// Do not edit this file directly
        \\
        \\import Foundation
        \\
        \\/// Font variation axis configuration
        \\public struct FontVariation {
        \\    public let axis: String
        \\    public let value: Float
        \\    
        \\    public init(axis: String, value: Float) {
        \\        self.axis = axis
        \\        self.value = value
        \\    }
        \\}
        \\
        \\/// Common font variation axes
        \\public extension FontVariation {
        \\    static func weight(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "wght", value: value)
        \\    }
        \\    
        \\    static func slant(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "slnt", value: value)
        \\    }
        \\    
        \\    static func italic(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "ital", value: value)
        \\    }
        \\    
        \\    static func opticalSize(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "opsz", value: value)
        \\    }
        \\    
        \\    static func width(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "wdth", value: value)
        \\    }
        \\    
        \\    static func grade(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "GRAD", value: value)
        \\    }
        \\}
        \\
        \\/// Configuration options for Ghostty
        \\public struct GhosttyConfig {
        \\
        \\
    );
}

fn generateSwiftFooter(writer: anytype) !void {
    try writer.writeAll(
        \\}
        \\
    );
}

fn genConfigFields(alloc: Allocator, writer: anytype) !void {
    var ast = std.zig.Ast.parse(alloc, @embedFile("config/Config.zig"), .zig) catch |err| {
        log.err("failed to parse Config.zig: {}", .{err});
        return GenerateError.ParseError;
    };
    defer ast.deinit(alloc);

    inline for (@typeInfo(Config).@"struct".fields) |field| {
        // Skip private fields (prefixed with underscore)
        if (field.name[0] == '_') continue;

        // Check if field is in the filtered list
        const filtered = comptime blk: {
            for (filtered_fields) |filtered_field| {
                if (std.mem.eql(u8, field.name, filtered_field)) {
                    break :blk true;
                }
            }
            break :blk false;
        };
        if (filtered) continue;

        genConfigField(alloc, writer, ast, field) catch |err| {
            log.warn("failed to generate field '{s}': {}", .{ field.name, err });
            // Continue to next field instead of using continue in catch block
        };
    }
}

fn genConfigField(
    alloc: Allocator,
    writer: anytype,
    ast: std.zig.Ast,
    comptime field: std.builtin.Type.StructField,
) !void {
    const tokens = ast.tokens.items(.tag);

    for (tokens, 0..) |token, i| {
        if (token != .identifier) continue;
        if (i == 0 or tokens[i - 1] != .doc_comment) continue;

        const name = ast.tokenSlice(@intCast(i));
        const key = if (name[0] == '@') name[2 .. name.len - 1] else name;
        if (!std.mem.eql(u8, key, field.name)) continue;

        const comment = extractDocComments(alloc, ast, @intCast(i - 1), tokens) catch |err| {
            log.warn("failed to extract doc comments for field '{s}': {}", .{ field.name, err });
            return err;
        };
        defer alloc.free(comment);

        try writer.writeAll(comment);
        try writer.writeAll("    public let ");

        const swift_name = convertToSwiftName(alloc, field.name) catch |err| {
            log.warn("failed to convert field name '{s}' to Swift: {}", .{ field.name, err });
            return err;
        };
        defer alloc.free(swift_name);
        try writer.writeAll(swift_name);
        try writer.writeAll(": ");

        const swift_type = zigTypeToSwiftType(alloc, field.type) catch |err| {
            log.warn("failed to convert type for field '{s}' to Swift: {}", .{ field.name, err });
            return err;
        };
        defer alloc.free(swift_type);
        try writer.writeAll(swift_type);
        try writer.writeAll("\n\n");
        break;
    }
}

fn extractDocComments(
    alloc: Allocator,
    ast: std.zig.Ast,
    index: std.zig.Ast.TokenIndex,
    tokens: []std.zig.Token.Tag,
) ![]const u8 {
    const start_idx: usize = start_idx: for (0..index) |i| {
        const reverse_i = index - i - 1;
        const token = tokens[reverse_i];
        if (token != .doc_comment) break :start_idx reverse_i + 1;
    } else unreachable;

    var lines = std.ArrayList([]const u8).init(alloc);
    defer lines.deinit();
    
    for (start_idx..index + 1) |i| {
        const token = tokens[i];
        if (token != .doc_comment) break;
        try lines.append(ast.tokenSlice(@intCast(i))[3..]);
    }

    var buffer = std.ArrayList(u8).init(alloc);
    errdefer buffer.deinit();
    
    const writer = buffer.writer();
    const prefix = findCommonPrefix(lines);

    try writer.writeAll("    /// ");
    for (lines.items, 0..) |line, idx| {
        if (idx > 0) try writer.writeAll("    /// ");
        try writer.writeAll(line[@min(prefix, line.len)..]);
        if (idx < lines.items.len - 1) try writer.writeAll("\n");
    }
    try writer.writeAll("\n");

    return buffer.toOwnedSlice();
}

fn findCommonPrefix(lines: std.ArrayList([]const u8)) usize {
    var m: usize = std.math.maxInt(usize);
    for (lines.items) |line| {
        var n: usize = std.math.maxInt(usize);
        for (line, 0..) |c, i| {
            if (c != ' ') {
                n = i;
                break;
            }
        }
        m = @min(m, n);
    }
    return m;
}

fn convertToSwiftName(alloc: Allocator, zig_name: []const u8) ![]const u8 {
    var result = std.ArrayList(u8).init(alloc);
    errdefer result.deinit();
    
    var capitalize_next = false;

    for (zig_name, 0..) |c, i| {
        if (c == '_' or c == '-') {
            capitalize_next = true;
        } else if (capitalize_next and i > 0) {
            try result.append(std.ascii.toUpper(c));
            capitalize_next = false;
        } else {
            try result.append(c);
        }
    }

    const camel_case_name = try result.toOwnedSlice();

    if (isSwiftReservedKeyword(camel_case_name)) {
        const wrapped = std.fmt.allocPrint(alloc, "`{s}`", .{camel_case_name}) catch |err| {
            alloc.free(camel_case_name);
            return err;
        };
        alloc.free(camel_case_name);
        return wrapped;
    }

    return camel_case_name;
}

/// Swift reserved keywords that need to be escaped with backticks
fn isSwiftReservedKeyword(name: []const u8) bool {
    const swift_keywords = [_][]const u8{
        "associatedtype", "class",       "deinit",       "enum",         "extension",   "fileprivate", "func",
        "import",         "init",        "inout",        "internal",     "let",         "open",        "operator",
        "private",        "protocol",    "public",       "static",       "struct",      "subscript",   "typealias",
        "var",            "break",       "case",         "continue",     "default",     "defer",       "do",
        "else",           "fallthrough", "for",          "guard",        "if",          "in",          "repeat",
        "return",         "switch",      "where",        "while",        "as",          "catch",       "false",
        "is",             "nil",         "rethrows",     "super",        "self",        "Self",        "throw",
        "throws",         "true",        "try",          "Any",          "Protocol",    "Type",        "associativity",
        "convenience",    "dynamic",     "didSet",       "final",        "get",         "indirect",    "infix",
        "lazy",           "left",        "mutating",     "none",         "nonmutating", "optional",    "override",
        "postfix",        "precedence",  "prefix",       "required",     "right",       "set",         "some",
        "unowned",        "weak",        "willSet",
    };

    for (swift_keywords) |keyword| {
        if (std.mem.eql(u8, name, keyword)) {
            return true;
        }
    }

    return false;
}

fn zigTypeToSwiftType(alloc: Allocator, comptime T: type) ![]const u8 {
    // Handle special Ghostty config types first
    if (T == configpkg.RepeatableFontVariation) {
        return try alloc.dupe(u8, "[FontVariation]");
    }
    if (T == configpkg.RepeatableString) {
        return try alloc.dupe(u8, "[String]");
    }
    if (T == configpkg.RepeatableCodepointMap) {
        return try alloc.dupe(u8, "[String: String]");
    }

    return switch (@typeInfo(T)) {
        .bool => try alloc.dupe(u8, "Bool"),
        .int => |info| switch (info.bits) {
            8 => try alloc.dupe(u8, if (info.signedness == .signed) "Int8" else "UInt8"),
            16 => try alloc.dupe(u8, if (info.signedness == .signed) "Int16" else "UInt16"),
            32 => try alloc.dupe(u8, if (info.signedness == .signed) "Int32" else "UInt32"),
            64 => try alloc.dupe(u8, if (info.signedness == .signed) "Int64" else "UInt64"),
            else => try alloc.dupe(u8, if (info.signedness == .signed) "Int" else "UInt"),
        },
        .float => |info| switch (info.bits) {
            32 => try alloc.dupe(u8, "Float"),
            64 => try alloc.dupe(u8, "Double"),
            else => try alloc.dupe(u8, "Double"),
        },
        .optional => |info| {
            const child_type = try zigTypeToSwiftType(alloc, info.child);
            defer alloc.free(child_type);
            return std.fmt.allocPrint(alloc, "{s}?", .{child_type});
        },
        .pointer => |info| switch (info.size) {
            .slice => {
                if (info.child == u8) {
                    return try alloc.dupe(u8, "String");
                } else {
                    const child_type = try zigTypeToSwiftType(alloc, info.child);
                    defer alloc.free(child_type);
                    return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
                }
            },
            .many => {
                if (info.child == u8) {
                    return try alloc.dupe(u8, "String");
                } else {
                    const child_type = try zigTypeToSwiftType(alloc, info.child);
                    defer alloc.free(child_type);
                    return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
                }
            },
            else => {
                const child_type = try zigTypeToSwiftType(alloc, info.child);
                defer alloc.free(child_type);
                return std.fmt.allocPrint(alloc, "UnsafePointer<{s}>", .{child_type});
            },
        },
        .array => |info| {
            if (info.child == u8) {
                return try alloc.dupe(u8, "String");
            } else {
                const child_type = try zigTypeToSwiftType(alloc, info.child);
                defer alloc.free(child_type);
                return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
            }
        },
        .@"enum" => try alloc.dupe(u8, "Int"),
        .@"struct" => try alloc.dupe(u8, "Any"),
        .@"union" => try alloc.dupe(u8, "Any"),
        else => try alloc.dupe(u8, "Any"),
    };
}

test "convertToSwiftName" {
    const testing = std.testing;
    const alloc = testing.allocator;

    {
        const result = try convertToSwiftName(alloc, "font_size");
        defer alloc.free(result);
        try testing.expectEqualStrings("fontSize", result);
    }

    {
        const result = try convertToSwiftName(alloc, "background-color");
        defer alloc.free(result);
        try testing.expectEqualStrings("backgroundColor", result);
    }

    {
        const result = try convertToSwiftName(alloc, "class");
        defer alloc.free(result);
        try testing.expectEqualStrings("`class`", result);
    }
}

test "isSwiftReservedKeyword" {
    try std.testing.expect(isSwiftReservedKeyword("class"));
    try std.testing.expect(isSwiftReservedKeyword("func"));
    try std.testing.expect(isSwiftReservedKeyword("var"));
    try std.testing.expect(!isSwiftReservedKeyword("fontSize"));
    try std.testing.expect(!isSwiftReservedKeyword("backgroundColor"));
}
