//! This program is used to generate Swift configuration types from the Zig
//! configuration file for Ghostty. This allows the macOS app to access
//! configuration options in a type-safe way.

const std = @import("std");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
const Config = @import("config/Config.zig");
const configpkg = @import("config.zig");

const log = std.log.scoped(.swift_config_gen);

/// Configuration fields to exclude from Swift generation (macOS-specific filtering)
const filtered_fields = [_][]const u8{
    "class",
    "x11-instance-name",
};

pub const GenerateError = error{
    OutOfMemory,
    WriteError,
    ParseError,
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer {
        const deinit_status = gpa.deinit();
        if (deinit_status == .leak) {
            log.err("memory leak detected", .{});
        }
    }
    const alloc = gpa.allocator();

    const stdout = std.io.getStdOut().writer();
    
    try generateSwiftHeader(stdout);
    genConfigFields(alloc, stdout) catch |err| {
        log.err("failed to generate config fields: {}", .{err});
        return err;
    };
    try generateSwiftFooter(stdout);
}

fn getSwiftTypeForConfigField(alloc: Allocator, field_name: []const u8) ![]const u8 {
    // Use comptime to generate a lookup for all config field types
    inline for (@typeInfo(Config).@"struct".fields) |config_field| {
        if (std.mem.eql(u8, config_field.name, field_name)) {
            return try zigTypeToSwiftType(alloc, config_field.type);
        }
    }
    
    return error.FieldNotFound;
}

fn generateSwiftHeader(writer: anytype) !void {
    try writer.writeAll(
        \\// THIS FILE IS AUTO GENERATED
        \\// Do not edit this file directly
        \\
        \\import Foundation
        \\
        \\/// Font variation axis configuration
        \\public struct FontVariation {
        \\    public let axis: String
        \\    public let value: Float
        \\    
        \\    public init(axis: String, value: Float) {
        \\        self.axis = axis
        \\        self.value = value
        \\    }
        \\}
        \\
        \\/// Common font variation axes
        \\public extension FontVariation {
        \\    static func weight(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "wght", value: value)
        \\    }
        \\    
        \\    static func slant(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "slnt", value: value)
        \\    }
        \\    
        \\    static func italic(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "ital", value: value)
        \\    }
        \\    
        \\    static func opticalSize(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "opsz", value: value)
        \\    }
        \\    
        \\    static func width(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "wdth", value: value)
        \\    }
        \\    
        \\    static func grade(_ value: Float) -> FontVariation {
        \\        FontVariation(axis: "GRAD", value: value)
        \\    }
        \\}
        \\
        \\/// Configuration options for Ghostty
        \\public struct GhosttyConfig {
        \\
        \\
    );
}

fn generateSwiftFooter(writer: anytype) !void {
    try writer.writeAll(
        \\}
        \\
    );
}

fn genConfigFields(alloc: Allocator, writer: anytype) !void {
    var ast = std.zig.Ast.parse(alloc, @embedFile("config/Config.zig"), .zig) catch |err| {
        log.err("failed to parse Config.zig: {}", .{err});
        return GenerateError.ParseError;
    };
    defer ast.deinit(alloc);

    // Simple approach: generate fields individually like helpgen.zig
    // but use a smarter grouping in the Swift output
    inline for (@typeInfo(Config).@"struct".fields) |field| {
        if (field.name[0] == '_') continue;

        // Check if field is in the filtered list
        const filtered = comptime blk: {
            for (filtered_fields) |filtered_field| {
                if (std.mem.eql(u8, field.name, filtered_field)) {
                    break :blk true;
                }
            }
            break :blk false;
        };
        if (filtered) continue;

        genConfigField(alloc, writer, ast, field) catch |err| {
            log.warn("failed to generate field '{s}': {}", .{ field.name, err });
        };
    }
}

fn extractFieldName(raw_name: []const u8) []const u8 {
    return if (raw_name[0] == '@') 
        raw_name[2 .. raw_name.len - 1] 
    else 
        raw_name;
}

fn findNextFieldIdentifier(tokens: []std.zig.Token.Tag, start_idx: usize) ?usize {
    var idx = start_idx;
    
    // Skip to next identifier
    while (idx < tokens.len and tokens[idx] != .identifier) {
        idx += 1;
    }
    if (idx >= tokens.len) return null;

    // Check if this identifier is preceded by a doc comment (meaning it's a new field group)
    if (idx > 0 and tokens[idx - 1] == .doc_comment) {
        return null; // This is the start of a new documentation block
    }

    // Check if this identifier is a field (followed by colon within a few tokens)
    for (idx + 1..@min(idx + 4, tokens.len)) |check_idx| {
        if (tokens[check_idx] == .colon) {
            return idx;
        }
    }
    
    // Not a field, keep searching
    return findNextFieldIdentifier(tokens, idx + 1);
}

fn generateSwiftDeclarations(alloc: Allocator, writer: anytype, fields: []const AdjacentFieldInfo) !void {
    var type_to_names = std.StringHashMap(std.ArrayList([]const u8)).init(alloc);
    defer {
        var iter = type_to_names.iterator();
        while (iter.next()) |entry| {
            entry.value_ptr.deinit();
        }
        type_to_names.deinit();
    }

    for (fields) |field| {
        const result = try type_to_names.getOrPut(field.swift_type);
        if (!result.found_existing) {
            result.value_ptr.* = std.ArrayList([]const u8).init(alloc);
        }
        try result.value_ptr.append(field.swift_name);
    }

    var iter = type_to_names.iterator();
    while (iter.next()) |entry| {
        const type_name = entry.key_ptr.*;
        const names = entry.value_ptr.items;
        
        try writer.writeAll("    public let ");
        for (names, 0..) |field_name, idx| {
            if (idx > 0) try writer.writeAll(", ");
            try writer.writeAll(field_name);
        }
        try writer.writeAll(": ");
        try writer.writeAll(type_name);
        try writer.writeAll("\n");
    }
    try writer.writeAll("\n");
}

fn genConfigField(
    alloc: Allocator,
    writer: anytype,
    ast: std.zig.Ast,
    comptime field: std.builtin.Type.StructField,
) !void {
    const tokens = ast.tokens.items(.tag);

    for (tokens, 0..) |token, i| {
        if (token != .identifier) continue;
        if (i == 0 or tokens[i - 1] != .doc_comment) continue;

        const name = ast.tokenSlice(@intCast(i));
        const key = extractFieldName(name);
        if (!std.mem.eql(u8, key, field.name)) continue;

        const comment = extractDocComments(alloc, ast, @intCast(i - 1), tokens) catch |err| {
            log.warn("failed to extract doc comments for field '{s}': {}", .{ field.name, err });
            return err;
        };
        defer alloc.free(comment);

        // Find all adjacent fields that share this documentation
        var adjacent_fields = std.ArrayList(AdjacentFieldInfo).init(alloc);
        defer {
            for (adjacent_fields.items) |item| {
                alloc.free(item.swift_name);
                alloc.free(item.swift_type);
            }
            adjacent_fields.deinit();
        }

        // Add the current field
        const swift_name = try convertToSwiftName(alloc, field.name);
        const swift_type = try zigTypeToSwiftType(alloc, field.type);
        try adjacent_fields.append(.{
            .swift_name = swift_name,
            .swift_type = swift_type,
        });

        // Look for adjacent fields that follow immediately after this one
        var search_idx = i + 1;
        while (search_idx < tokens.len) {
            search_idx = findNextFieldIdentifier(tokens, search_idx) orelse break;

            const next_field_name_raw = ast.tokenSlice(@intCast(search_idx));
            const next_field_name = extractFieldName(next_field_name_raw);

            // Skip private fields
            if (next_field_name[0] == '_') {
                search_idx += 1;
                continue;
            }

            // Check if this field exists in Config and get its type
            const next_swift_type = getSwiftTypeForConfigField(alloc, next_field_name) catch {
                search_idx += 1;
                continue;
            };

            const next_swift_name = try convertToSwiftName(alloc, next_field_name);
            try adjacent_fields.append(.{
                .swift_name = next_swift_name,
                .swift_type = next_swift_type,
            });

            search_idx += 1;
        }

        // Generate Swift output - group by type for adjacent declaration
        try writer.writeAll(comment);
        try generateSwiftDeclarations(alloc, writer, adjacent_fields.items);
        
        break;
    }
}

const AdjacentFieldInfo = struct {
    swift_name: []const u8,
    swift_type: []const u8,
};

fn extractDocComments(
    alloc: Allocator,
    ast: std.zig.Ast,
    index: std.zig.Ast.TokenIndex,
    tokens: []std.zig.Token.Tag,
) ![]const u8 {
    const start_idx: usize = start_idx: for (0..index) |i| {
        const reverse_i = index - i - 1;
        const token = tokens[reverse_i];
        if (token != .doc_comment) break :start_idx reverse_i + 1;
    } else unreachable;

    var lines = std.ArrayList([]const u8).init(alloc);
    defer lines.deinit();
    
    for (start_idx..index + 1) |i| {
        const token = tokens[i];
        if (token != .doc_comment) break;
        try lines.append(ast.tokenSlice(@intCast(i))[3..]);
    }

    var buffer = std.ArrayList(u8).init(alloc);
    errdefer buffer.deinit();
    
    const writer = buffer.writer();
    const prefix = findCommonPrefix(lines);

    try writer.writeAll("    /// ");
    for (lines.items, 0..) |line, idx| {
        if (idx > 0) try writer.writeAll("    /// ");
        try writer.writeAll(line[@min(prefix, line.len)..]);
        if (idx < lines.items.len - 1) try writer.writeAll("\n");
    }
    try writer.writeAll("\n");

    return buffer.toOwnedSlice();
}

fn findCommonPrefix(lines: std.ArrayList([]const u8)) usize {
    var m: usize = std.math.maxInt(usize);
    for (lines.items) |line| {
        var n: usize = std.math.maxInt(usize);
        for (line, 0..) |c, i| {
            if (c != ' ') {
                n = i;
                break;
            }
        }
        m = @min(m, n);
    }
    return m;
}

fn convertToSwiftName(alloc: Allocator, zig_name: []const u8) ![]const u8 {
    var result = std.ArrayList(u8).init(alloc);
    errdefer result.deinit();
    
    var capitalize_next = false;

    for (zig_name, 0..) |c, i| {
        if (c == '_' or c == '-') {
            capitalize_next = true;
        } else if (capitalize_next and i > 0) {
            try result.append(std.ascii.toUpper(c));
            capitalize_next = false;
        } else {
            try result.append(c);
        }
    }

    const camel_case_name = try result.toOwnedSlice();

    if (isSwiftReservedKeyword(camel_case_name)) {
        const wrapped = std.fmt.allocPrint(alloc, "`{s}`", .{camel_case_name}) catch |err| {
            alloc.free(camel_case_name);
            return err;
        };
        alloc.free(camel_case_name);
        return wrapped;
    }

    return camel_case_name;
}

/// Swift reserved keywords that need to be escaped with backticks
fn isSwiftReservedKeyword(name: []const u8) bool {
    const swift_keywords = [_][]const u8{
        "associatedtype", "class",       "deinit",       "enum",         "extension",   "fileprivate", "func",
        "import",         "init",        "inout",        "internal",     "let",         "open",        "operator",
        "private",        "protocol",    "public",       "static",       "struct",      "subscript",   "typealias",
        "var",            "break",       "case",         "continue",     "default",     "defer",       "do",
        "else",           "fallthrough", "for",          "guard",        "if",          "in",          "repeat",
        "return",         "switch",      "where",        "while",        "as",          "catch",       "false",
        "is",             "nil",         "rethrows",     "super",        "self",        "Self",        "throw",
        "throws",         "true",        "try",          "Any",          "Protocol",    "Type",        "associativity",
        "convenience",    "dynamic",     "didSet",       "final",        "get",         "indirect",    "infix",
        "lazy",           "left",        "mutating",     "none",         "nonmutating", "optional",    "override",
        "postfix",        "precedence",  "prefix",       "required",     "right",       "set",         "some",
        "unowned",        "weak",        "willSet",
    };

    for (swift_keywords) |keyword| {
        if (std.mem.eql(u8, name, keyword)) {
            return true;
        }
    }

    return false;
}

fn zigTypeToSwiftType(alloc: Allocator, comptime T: type) ![]const u8 {
    // Handle special Ghostty config types first
    if (T == configpkg.RepeatableFontVariation) {
        return try alloc.dupe(u8, "[FontVariation]");
    }
    if (T == configpkg.RepeatableString) {
        return try alloc.dupe(u8, "[String]");
    }
    if (T == configpkg.RepeatableCodepointMap) {
        return try alloc.dupe(u8, "[String: String]");
    }

    return switch (@typeInfo(T)) {
        .bool => try alloc.dupe(u8, "Bool"),
        .int => |info| switch (info.bits) {
            8 => try alloc.dupe(u8, if (info.signedness == .signed) "Int8" else "UInt8"),
            16 => try alloc.dupe(u8, if (info.signedness == .signed) "Int16" else "UInt16"),
            32 => try alloc.dupe(u8, if (info.signedness == .signed) "Int32" else "UInt32"),
            64 => try alloc.dupe(u8, if (info.signedness == .signed) "Int64" else "UInt64"),
            else => try alloc.dupe(u8, if (info.signedness == .signed) "Int" else "UInt"),
        },
        .float => |info| switch (info.bits) {
            32 => try alloc.dupe(u8, "Float"),
            64 => try alloc.dupe(u8, "Double"),
            else => try alloc.dupe(u8, "Double"),
        },
        .optional => |info| {
            const child_type = try zigTypeToSwiftType(alloc, info.child);
            defer alloc.free(child_type);
            return std.fmt.allocPrint(alloc, "{s}?", .{child_type});
        },
        .pointer => |info| switch (info.size) {
            .slice => {
                if (info.child == u8) {
                    return try alloc.dupe(u8, "String");
                } else {
                    const child_type = try zigTypeToSwiftType(alloc, info.child);
                    defer alloc.free(child_type);
                    return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
                }
            },
            .many => {
                if (info.child == u8) {
                    return try alloc.dupe(u8, "String");
                } else {
                    const child_type = try zigTypeToSwiftType(alloc, info.child);
                    defer alloc.free(child_type);
                    return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
                }
            },
            else => {
                const child_type = try zigTypeToSwiftType(alloc, info.child);
                defer alloc.free(child_type);
                return std.fmt.allocPrint(alloc, "UnsafePointer<{s}>", .{child_type});
            },
        },
        .array => |info| {
            if (info.child == u8) {
                return try alloc.dupe(u8, "String");
            } else {
                const child_type = try zigTypeToSwiftType(alloc, info.child);
                defer alloc.free(child_type);
                return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
            }
        },
        .@"enum" => try alloc.dupe(u8, "Int"),
        .@"struct" => try alloc.dupe(u8, "Any"),
        .@"union" => try alloc.dupe(u8, "Any"),
        else => try alloc.dupe(u8, "Any"),
    };
}

test "convertToSwiftName" {
    const testing = std.testing;
    const alloc = testing.allocator;

    {
        const result = try convertToSwiftName(alloc, "font_size");
        defer alloc.free(result);
        try testing.expectEqualStrings("fontSize", result);
    }

    {
        const result = try convertToSwiftName(alloc, "background-color");
        defer alloc.free(result);
        try testing.expectEqualStrings("backgroundColor", result);
    }

    {
        const result = try convertToSwiftName(alloc, "class");
        defer alloc.free(result);
        try testing.expectEqualStrings("`class`", result);
    }
}

test "isSwiftReservedKeyword" {
    try std.testing.expect(isSwiftReservedKeyword("class"));
    try std.testing.expect(isSwiftReservedKeyword("func"));
    try std.testing.expect(isSwiftReservedKeyword("var"));
    try std.testing.expect(!isSwiftReservedKeyword("fontSize"));
    try std.testing.expect(!isSwiftReservedKeyword("backgroundColor"));
}
