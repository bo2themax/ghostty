//! This program generates Swift configuration types from the Zig configuration file 
//! for Ghostty. This allows the macOS app to access configuration options in a 
//! type-safe way.
//!
//! ## Architecture
//! 
//! The generator works in several phases:
//! 1. Parse Config.zig to extract field documentation and types
//! 2. Convert Zig types to appropriate Swift types using type mapping
//! 3. Generate Swift enums for known configuration enums
//! 4. Generate Swift struct with optional properties
//!
//! ## Adding New Types
//!
//! When Config.zig introduces new types that aren't handled, they will default
//! to `String` type in Swift. To add proper type support:
//!
//! ### For Enum Types:
//! 1. Add enum generation function in the "Swift Enum Generators" section
//! 2. Call it from `generateConfigurationEnums()`
//! 3. Add mapping in `handleKnownEnumByName()` to return the enum name
//!
//! ### For Struct Types: 
//! 1. Add mapping in `handleKnownStructByName()` based on type name patterns
//! 2. Return appropriate Swift type (String, Float, CGSize, etc.)
//!
//! ### For Union Types:
//! 1. Add mapping in `handleKnownUnionByName()` based on type name patterns
//! 2. Usually map to String for flexibility
//!
//! **Note**: Unknown types automatically default to `String` for safety.
//! Check the generated Swift file for `String` types that should be more specific.

const std = @import("std");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
const Config = @import("config/Config.zig");
const configpkg = @import("config.zig");

const log = std.log.scoped(.swift_config_gen);

// ============================================================================
// MARK: - Configuration and Types
// ============================================================================

/// Configuration for Swift code generation
const GenerationConfig = struct {
    /// Whether to add 'public' visibility modifiers to generated types
    use_public_visibility: bool = false,
};

/// Information about adjacent fields that share documentation
const AdjacentFieldInfo = struct {
    swift_name: []const u8,
    swift_type: []const u8,
};

/// Configuration fields to exclude from Swift generation (macOS-specific filtering)
const filtered_fields = std.StaticStringMap(void).initComptime(.{
    .{"class"},
    .{"x11-instance-name"},
    .{"link"}, // this is a Todo field, ignore for now
    .{"window-subtitle"},
    .{"window-show-tab-bar"},
    .{"window-titlebar-background"},
    .{"window-titlebar-foreground"},
    .{"async-backend"},
});

pub const GenerateError = error{
    OutOfMemory,
    WriteError,
    ParseError,
};

// ============================================================================
// MARK: - Main Entry Point
// ============================================================================

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer {
        const deinit_status = gpa.deinit();
        if (deinit_status == .leak) {
            log.err("memory leak detected", .{});
        }
    }
    const alloc = gpa.allocator();

    const stdout = std.io.getStdOut().writer();
    
    const config = GenerationConfig{}; // Use default config for now
    
    try generateSwiftHeader(stdout, config);
    genConfigFields(alloc, stdout, config) catch |err| {
        log.err("failed to generate config fields: {}", .{err});
        return err;
    };
    try generateSwiftFooter(stdout);
}

// ============================================================================
// MARK: - Swift File Structure Generation
// ============================================================================

/// Generate the Swift file header with imports and common types
fn generateSwiftHeader(writer: anytype, config: GenerationConfig) !void {
    const visibility = if (config.use_public_visibility) "public " else "";
    
    // File header
    try writer.writeAll(
        \\// THIS FILE IS AUTO GENERATED
        \\// Do not edit this file directly
        \\
        \\import Foundation
        \\
        \\
    );
    
    // FontVariation struct and extension
    try generateFontVariation(writer, visibility);
    
    try writer.writeAll("\n// MARK: - Configuration Enums\n\n");
    
    // Generate all enums
    try generateConfigurationEnums(writer, visibility);
    
    // Start GhosttyConfig struct
    try writer.print("\n/// Configuration options for Ghostty\n{s}struct GhosttyConfig {{\n\n", .{visibility});
}

/// Generate FontVariation struct and its extensions
fn generateFontVariation(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// Font variation axis configuration
        \\{s}struct FontVariation {{
        \\    {s}let axis: String
        \\    {s}let value: Float
        \\
        \\    {s}init(axis: String, value: Float) {{
        \\        self.axis = axis
        \\        self.value = value
        \\    }}
        \\}}
        \\
    , .{ visibility, visibility, visibility, visibility });
    
    try writer.print(
        \\
        \\/// Common font variation axes
        \\{s}extension FontVariation {{
        \\    static func weight(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "wght", value: value)
        \\    }}
        \\
        \\    static func slant(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "slnt", value: value)
        \\    }}
        \\
        \\    static func italic(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "ital", value: value)
        \\    }}
        \\
        \\    static func opticalSize(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "opsz", value: value)
        \\    }}
        \\
        \\    static func width(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "wdth", value: value)
        \\    }}
        \\
        \\    static func grade(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "GRAD", value: value)
        \\    }}
        \\}}
        \\
    , .{visibility});
}

/// Generate the Swift file footer
fn generateSwiftFooter(writer: anytype) !void {
    try writer.writeAll(
        \\}
        \\
    );
}

// ============================================================================
// MARK: - Swift Enum Generators
// ============================================================================

/// Generate all configuration enums
fn generateConfigurationEnums(writer: anytype, visibility: []const u8) !void {
    try generateCursorStyleEnum(writer, visibility);
    try generateFontEnums(writer, visibility);
    try generateImageEnums(writer, visibility);
    try generateInteractionEnums(writer, visibility);
    try generateRenderingEnums(writer, visibility);
    try generateWindowEnums(writer, visibility);
    try generateMacOSEnums(writer, visibility);
    try generateGtkEnums(writer, visibility);
    try generateFreetypeStruct(writer, visibility);
}

fn generateCursorStyleEnum(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// Cursor style for the terminal
        \\{s}enum CursorStyle: String {{
        \\    case bar, block, underline
        \\    case blockHollow = "block_hollow"
        \\}}
        \\
    , .{visibility});
}

fn generateFontEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\
        \\/// Font synthetic style options
        \\{s}enum FontSyntheticStyle: String {{
        \\    case none, bold, italic, all
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\
        \\/// Font shaping line break options
        \\{s}enum FontShapingBreak: String {{
        \\    case word, anywhere
        \\}}
        \\
    , .{visibility});
}

fn generateImageEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\
        \\/// Background image positioning
        \\{s}enum BackgroundImagePosition: String {{
        \\    case center
        \\    case topLeft = "top-left"
        \\    case topCenter = "top-center"
        \\    case topRight = "top-right"
        \\    case bottomLeft = "bottom-left"
        \\    case bottomCenter = "bottom-center"
        \\    case bottomRight = "bottom-right"
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\
        \\/// Background image fit options
        \\{s}enum BackgroundImageFit: String {{
        \\    case fill, contain, cover, stretch
        \\}}
        \\
    , .{visibility});
}

fn generateInteractionEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\
        \\/// Clipboard access control
        \\{s}enum ClipboardAccess: String {{
        \\    case allow, deny, ask
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\
        \\/// Copy on select behavior
        \\{s}enum CopyOnSelect: String {{
        \\    case never, always, clipboard
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\
        \\/// Right click action
        \\{s}enum RightClickAction: String {{
        \\    case paste, menu, none
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\
        \\/// Window theme options
        \\{s}enum WindowTheme: String {{
        \\    case auto, light, dark, system
        \\}}
        \\
    , .{visibility});
}

fn generateRenderingEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\
        \\/// Alpha blending style options
        \\{s}enum AlphaBlending: String {{
        \\    case straight, premultiplied
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\
        \\/// Grapheme width calculation method
        \\{s}enum GraphemeWidthMethod: String {{
        \\    case unicode, legacy, wezterm
        \\}}
        \\
    , .{visibility});
}

fn generateFreetypeStruct(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\
        \\/// FreeType load flags
        \\{s}struct FreetypeLoadFlags: OptionSet {{
        \\    {s}let rawValue: Int
        \\    {s}init(rawValue: Int) {{ self.rawValue = rawValue }}
        \\
        \\    {s}static let defaultFlags: FreetypeLoadFlags = []
        \\    {s}static let noHinting = FreetypeLoadFlags(rawValue: 1 << 0)
        \\    {s}static let forceAutoHint = FreetypeLoadFlags(rawValue: 1 << 1)
        \\    {s}static let noBitmap = FreetypeLoadFlags(rawValue: 1 << 2)
        \\}}
        \\
    , .{ visibility, visibility, visibility, visibility, visibility, visibility, visibility });
}

fn generateWindowEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\
        \\/// Window save state options
        \\{s}enum WindowSaveState: String {{
        \\    case never, `default`, always
        \\}}
        \\
        \\/// Window new tab position
        \\{s}enum WindowNewTabPosition: String {{
        \\    case current, end
        \\}}
        \\
        \\/// Shell integration options
        \\{s}enum ShellIntegration: String {{
        \\    case none, fish, bash, zsh
        \\}}
        \\
    , .{ visibility, visibility, visibility });
}

fn generateMacOSEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\
        \\/// macOS window buttons position
        \\{s}enum MacWindowButtons: String {{
        \\    case left, right, hidden
        \\}}
        \\
        \\/// macOS titlebar style
        \\{s}enum MacTitlebarStyle: String {{
        \\    case native, tabs, transparent
        \\}}
        \\
        \\/// macOS app icon options
        \\{s}enum MacAppIcon: String {{
        \\    case ghost, terminal, blueprint, chalkboard, microchip, glass, holographic, paper, retro, xray
        \\    case custom = "custom"
        \\}}
        \\
        \\/// macOS Dock drop behavior
        \\{s}enum MacOSDockDropBehavior: String {{
        \\    case newWindow = "new-window"
        \\    case newTab = "new-tab"
        \\    case currentTab = "current-tab"
        \\}}
        \\
    , .{ visibility, visibility, visibility, visibility });
}

fn generateGtkEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\
        \\/// GTK tabs location
        \\{s}enum GtkTabsLocation: String {{
        \\    case top, bottom, left, right
        \\}}
        \\
        \\/// GTK single instance mode
        \\{s}enum GtkSingleInstance: String {{
        \\    case desktop, session, never
        \\}}
        \\
    , .{ visibility, visibility });
}

// ============================================================================
// MARK: - Config Field Processing
// ============================================================================

/// Process all configuration fields from Config.zig
fn genConfigFields(alloc: Allocator, writer: anytype, config: GenerationConfig) !void {
    var ast = std.zig.Ast.parse(alloc, @embedFile("config/Config.zig"), .zig) catch |err| {
        log.err("failed to parse Config.zig: {}", .{err});
        return GenerateError.ParseError;
    };
    defer ast.deinit(alloc);

    // Simple approach: generate fields individually like helpgen.zig
    // but use a smarter grouping in the Swift output
    inline for (@typeInfo(Config).@"struct".fields) |field| {
        if (field.name[0] == '_') continue;

        // Check if field is in the filtered list
        const filtered = comptime filtered_fields.has(field.name);
        if (filtered) continue;

        genConfigField(alloc, writer, ast, field, config) catch |err| {
            log.warn("failed to generate field '{s}': {}", .{ field.name, err });
        };
    }
}

/// Get Swift type for a specific config field name
fn getSwiftTypeForConfigField(alloc: Allocator, field_name: []const u8) ![]const u8 {
    // Use comptime to generate a lookup for all config field types
    inline for (@typeInfo(Config).@"struct".fields) |config_field| {
        if (std.mem.eql(u8, config_field.name, field_name)) {
            return try zigTypeToSwiftType(alloc, config_field.type);
        }
    }
    
    return error.FieldNotFound;
}

/// Generate a single config field and its adjacent fields
fn genConfigField(
    alloc: Allocator,
    writer: anytype,
    ast: std.zig.Ast,
    comptime field: std.builtin.Type.StructField,
    config: GenerationConfig,
) !void {
    const tokens = ast.tokens.items(.tag);

    for (tokens, 0..) |token, i| {
        if (token != .identifier) continue;
        if (i == 0 or tokens[i - 1] != .doc_comment) continue;

        const name = ast.tokenSlice(@intCast(i));
        const key = extractFieldName(name);
        if (!std.mem.eql(u8, key, field.name)) continue;

        const comment = extractDocComments(alloc, ast, @intCast(i - 1), tokens) catch |err| {
            log.warn("failed to extract doc comments for field '{s}': {}", .{ field.name, err });
            return err;
        };
        defer alloc.free(comment);

        // Find all adjacent fields that share this documentation
        var adjacent_fields = std.ArrayList(AdjacentFieldInfo).init(alloc);
        defer {
            for (adjacent_fields.items) |item| {
                alloc.free(item.swift_name);
                alloc.free(item.swift_type);
            }
            adjacent_fields.deinit();
        }

        // Add the current field
        const swift_name = try convertToSwiftName(alloc, field.name);
        const swift_type = try zigTypeToSwiftType(alloc, field.type);
        try adjacent_fields.append(.{
            .swift_name = swift_name,
            .swift_type = swift_type,
        });

        // Look for adjacent fields that follow immediately after this one
        var search_idx = i + 1;
        while (search_idx < tokens.len) {
            search_idx = findNextFieldIdentifier(tokens, search_idx) orelse break;

            const next_field_name_raw = ast.tokenSlice(@intCast(search_idx));
            const next_field_name = extractFieldName(next_field_name_raw);

            // Skip private fields
            if (next_field_name[0] == '_') {
                search_idx += 1;
                continue;
            }

            // Check if this field exists in Config and get its type
            const next_swift_type = getSwiftTypeForConfigField(alloc, next_field_name) catch {
                search_idx += 1;
                continue;
            };

            const next_swift_name = try convertToSwiftName(alloc, next_field_name);
            try adjacent_fields.append(.{
                .swift_name = next_swift_name,
                .swift_type = next_swift_type,
            });

            search_idx += 1;
        }

        // Generate Swift output - group by type for adjacent declaration
        try writer.writeAll(comment);
        try generateSwiftDeclarations(alloc, writer, adjacent_fields.items, config);
        
        break;
    }
}

// ============================================================================
// MARK: - AST Parsing Helpers
// ============================================================================

/// Extract field name from raw AST identifier (handles @"field-name" syntax)
fn extractFieldName(raw_name: []const u8) []const u8 {
    return if (raw_name[0] == '@') 
        raw_name[2 .. raw_name.len - 1] 
    else 
        raw_name;
}

fn findNextFieldIdentifier(tokens: []std.zig.Token.Tag, start_idx: usize) ?usize {
    var idx = start_idx;
    
    // Skip to next identifier
    while (idx < tokens.len and tokens[idx] != .identifier) {
        idx += 1;
    }
    if (idx >= tokens.len) return null;

    // Check if this identifier is preceded by a doc comment (meaning it's a new field group)
    if (idx > 0 and tokens[idx - 1] == .doc_comment) {
        return null; // This is the start of a new documentation block
    }

    // Check if this identifier is a field (followed by colon within a few tokens)
    for (idx + 1..@min(idx + 4, tokens.len)) |check_idx| {
        if (tokens[check_idx] == .colon) {
            return idx;
        }
    }
    
    // Not a field, keep searching
    return findNextFieldIdentifier(tokens, idx + 1);
}

/// Extract documentation comments from AST tokens
fn extractDocComments(
    alloc: Allocator,
    ast: std.zig.Ast,
    index: std.zig.Ast.TokenIndex,
    tokens: []std.zig.Token.Tag,
) ![]const u8 {
    const start_idx: usize = start_idx: for (0..index) |i| {
        const reverse_i = index - i - 1;
        const token = tokens[reverse_i];
        if (token != .doc_comment) break :start_idx reverse_i + 1;
    } else unreachable;

    var lines = std.ArrayList([]const u8).init(alloc);
    defer lines.deinit();
    
    for (start_idx..index + 1) |i| {
        const token = tokens[i];
        if (token != .doc_comment) break;
        try lines.append(ast.tokenSlice(@intCast(i))[3..]);
    }

    var buffer = std.ArrayList(u8).init(alloc);
    errdefer buffer.deinit();
    
    const writer = buffer.writer();
    const prefix = findCommonPrefix(lines);

    try writer.writeAll("    /// ");
    for (lines.items, 0..) |line, idx| {
        if (idx > 0) try writer.writeAll("    /// ");
        try writer.writeAll(line[@min(prefix, line.len)..]);
        if (idx < lines.items.len - 1) try writer.writeAll("\n");
    }
    try writer.writeAll("\n");

    return buffer.toOwnedSlice();
}

/// Find common whitespace prefix in documentation lines
fn findCommonPrefix(lines: std.ArrayList([]const u8)) usize {
    var m: usize = std.math.maxInt(usize);
    for (lines.items) |line| {
        var n: usize = std.math.maxInt(usize);
        for (line, 0..) |c, i| {
            if (c != ' ') {
                n = i;
                break;
            }
        }
        m = @min(m, n);
    }
    return m;
}

// ============================================================================
// MARK: - Name Conversion Utilities
// ============================================================================

fn generateSwiftDeclarations(alloc: Allocator, writer: anytype, fields: []const AdjacentFieldInfo, config: GenerationConfig) !void {
    var type_to_names = std.StringHashMap(std.ArrayList([]const u8)).init(alloc);
    defer {
        var iter = type_to_names.iterator();
        while (iter.next()) |entry| {
            entry.value_ptr.deinit();
        }
        type_to_names.deinit();
    }

    for (fields) |field| {
        const result = try type_to_names.getOrPut(field.swift_type);
        if (!result.found_existing) {
            result.value_ptr.* = std.ArrayList([]const u8).init(alloc);
        }
        try result.value_ptr.append(field.swift_name);
    }

    const visibility = if (config.use_public_visibility) "public " else "";
    
    var iter = type_to_names.iterator();
    while (iter.next()) |entry| {
        const type_name = entry.key_ptr.*;
        const names = entry.value_ptr.items;
        
        try writer.print("    {s}var ", .{visibility});
        for (names, 0..) |field_name, idx| {
            if (idx > 0) try writer.writeAll(", ");
            try writer.writeAll(field_name);
        }
        try writer.writeAll(": ");
        try writer.writeAll(type_name);
        // Always use optional here, for easier initialization
        const optional_suffix = if (std.mem.endsWith(u8, type_name, "?")) "" else "?";
        try writer.writeAll(optional_suffix);
        try writer.writeAll("\n");
    }
    try writer.writeAll("\n");
}

fn convertToSwiftName(alloc: Allocator, zig_name: []const u8) ![]const u8 {
    var result = std.ArrayList(u8).init(alloc);
    errdefer result.deinit();
    
    var capitalize_next = false;

    for (zig_name, 0..) |c, i| {
        if (c == '_' or c == '-') {
            capitalize_next = true;
        } else if (capitalize_next and i > 0) {
            try result.append(std.ascii.toUpper(c));
            capitalize_next = false;
        } else {
            try result.append(c);
        }
    }

    const camel_case_name = try result.toOwnedSlice();

    if (isSwiftReservedKeyword(camel_case_name)) {
        const wrapped = std.fmt.allocPrint(alloc, "`{s}`", .{camel_case_name}) catch |err| {
            alloc.free(camel_case_name);
            return err;
        };
        alloc.free(camel_case_name);
        return wrapped;
    }

    return camel_case_name;
}

/// Swift reserved keywords that need to be escaped with backticks
fn isSwiftReservedKeyword(name: []const u8) bool {
    const swift_keywords = [_][]const u8{
        "associatedtype", "class",       "deinit",       "enum",         "extension",   "fileprivate", "func",
        "import",         "init",        "inout",        "internal",     "let",         "open",        "operator",
        "private",        "protocol",    "public",       "static",       "struct",      "subscript",   "typealias",
        "var",            "break",       "case",         "continue",     "default",     "defer",       "do",
        "else",           "fallthrough", "for",          "guard",        "if",          "in",          "repeat",
        "return",         "switch",      "where",        "while",        "as",          "catch",       "false",
        "is",             "nil",         "rethrows",     "super",        "self",        "Self",        "throw",
        "throws",         "true",        "try",          "Any",          "Protocol",    "Type",        "associativity",
        "convenience",    "dynamic",     "didSet",       "final",        "get",         "indirect",    "infix",
        "lazy",           "left",        "mutating",     "none",         "nonmutating", "optional",    "override",
        "postfix",        "precedence",  "prefix",       "required",     "right",       "set",         "some",
        "unowned",        "weak",        "willSet",
    };

    for (swift_keywords) |keyword| {
        if (std.mem.eql(u8, name, keyword)) {
            return true;
        }
    }

    return false;
}

// ============================================================================
// MARK: - Type Mapping System  
// ============================================================================
// This section handles converting Zig types to appropriate Swift types.
// When adding support for new types, modify the appropriate handler function.

/// Main type conversion function - converts Zig types to Swift types
fn zigTypeToSwiftType(alloc: Allocator, comptime T: type) ![]const u8 {
    // Handle special Ghostty config types first
    if (T == configpkg.RepeatableFontVariation) {
        return try alloc.dupe(u8, "[FontVariation]");
    }
    if (T == configpkg.RepeatableString) {
        return try alloc.dupe(u8, "[String]");
    }
    if (T == configpkg.RepeatableCodepointMap) {
        return try alloc.dupe(u8, "[String: String]");
    }

    return switch (@typeInfo(T)) {
        .bool => try alloc.dupe(u8, "Bool"),
        .int => |info| switch (info.bits) {
            8 => try alloc.dupe(u8, if (info.signedness == .signed) "Int8" else "UInt8"),
            16 => try alloc.dupe(u8, if (info.signedness == .signed) "Int16" else "UInt16"),
            32 => try alloc.dupe(u8, if (info.signedness == .signed) "Int32" else "UInt32"),
            64 => try alloc.dupe(u8, if (info.signedness == .signed) "Int64" else "UInt64"),
            else => try alloc.dupe(u8, if (info.signedness == .signed) "Int" else "UInt"),
        },
        .float => |info| switch (info.bits) {
            32 => try alloc.dupe(u8, "Float"),
            64 => try alloc.dupe(u8, "Double"),
            else => try alloc.dupe(u8, "Double"),
        },
        .optional => |info| {
            const child_type = try zigTypeToSwiftType(alloc, info.child);
            defer alloc.free(child_type);
            return std.fmt.allocPrint(alloc, "{s}?", .{child_type});
        },
        .pointer => |info| switch (info.size) {
            .slice => {
                if (info.child == u8) {
                    return try alloc.dupe(u8, "String");
                } else {
                    const child_type = try zigTypeToSwiftType(alloc, info.child);
                    defer alloc.free(child_type);
                    return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
                }
            },
            .many => {
                if (info.child == u8) {
                    return try alloc.dupe(u8, "String");
                } else {
                    const child_type = try zigTypeToSwiftType(alloc, info.child);
                    defer alloc.free(child_type);
                    return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
                }
            },
            else => {
                const child_type = try zigTypeToSwiftType(alloc, info.child);
                defer alloc.free(child_type);
                return std.fmt.allocPrint(alloc, "UnsafePointer<{s}>", .{child_type});
            },
        },
        .array => |info| {
            if (info.child == u8) {
                return try alloc.dupe(u8, "String");
            } else {
                const child_type = try zigTypeToSwiftType(alloc, info.child);
                defer alloc.free(child_type);
                return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
            }
        },
        .@"enum" => {
            // Check if this is a known enum type by name
            const type_name = @typeName(T);
            return try handleKnownEnumByName(alloc, type_name);
        },
        .@"struct" => {
            // Check if this is a known struct type by name  
            const type_name = @typeName(T);
            return try handleKnownStructByName(alloc, type_name);
        },
        .@"union" => {
            // Check if this is a known union type by name
            const type_name = @typeName(T);
            return try handleKnownUnionByName(alloc, type_name);
        },
        else => try alloc.dupe(u8, "String"),
    };
}

/// Handle union types by name pattern matching
/// Add new union type mappings here when Config.zig introduces them
fn handleKnownUnionByName(alloc: Allocator, type_name: []const u8) ![]const u8 {
    // FontStyle union type - can be default, false, or a named style
    if (std.mem.indexOf(u8, type_name, "FontStyle") != null) {
        return try alloc.dupe(u8, "String"); // Use String for flexibility
    }
    
    // Other known union types can be added here
    
    // Default for unknown unions - use String for safety
    return try alloc.dupe(u8, "String");
}

/// Handle enum types by name pattern matching
/// Add new enum type mappings here when Config.zig introduces them
fn handleKnownEnumByName(alloc: Allocator, type_name: []const u8) ![]const u8 {
    // Basic UI enums we generate
    if (std.mem.indexOf(u8, type_name, "CursorStyle") != null) {
        return try alloc.dupe(u8, "CursorStyle");
    }
    if (std.mem.indexOf(u8, type_name, "AlphaBlending") != null) {
        return try alloc.dupe(u8, "AlphaBlending");
    }
    if (std.mem.indexOf(u8, type_name, "GraphemeWidthMethod") != null) {
        return try alloc.dupe(u8, "GraphemeWidthMethod");
    }
    if (std.mem.indexOf(u8, type_name, "ClipboardAccess") != null) {
        return try alloc.dupe(u8, "ClipboardAccess");
    }
    if (std.mem.indexOf(u8, type_name, "CopyOnSelect") != null) {
        return try alloc.dupe(u8, "CopyOnSelect");
    }
    if (std.mem.indexOf(u8, type_name, "RightClickAction") != null) {
        return try alloc.dupe(u8, "RightClickAction");
    }
    if (std.mem.indexOf(u8, type_name, "WindowTheme") != null) {
        return try alloc.dupe(u8, "WindowTheme");
    }
    if (std.mem.indexOf(u8, type_name, "BackgroundImagePosition") != null) {
        return try alloc.dupe(u8, "BackgroundImagePosition");
    }
    if (std.mem.indexOf(u8, type_name, "BackgroundImageFit") != null) {
        return try alloc.dupe(u8, "BackgroundImageFit");
    }
    
    // Additional Config enums that are now Swift enums (instead of String)
    if (std.mem.indexOf(u8, type_name, "WindowSaveState") != null) {
        return try alloc.dupe(u8, "WindowSaveState");
    }
    if (std.mem.indexOf(u8, type_name, "WindowNewTabPosition") != null) {
        return try alloc.dupe(u8, "WindowNewTabPosition");
    }
    if (std.mem.indexOf(u8, type_name, "ShellIntegration") != null) {
        return try alloc.dupe(u8, "ShellIntegration");
    }
    if (std.mem.indexOf(u8, type_name, "MacWindowButtons") != null) {
        return try alloc.dupe(u8, "MacWindowButtons");
    }
    if (std.mem.indexOf(u8, type_name, "MacTitlebarStyle") != null) {
        return try alloc.dupe(u8, "MacTitlebarStyle");
    }
    if (std.mem.indexOf(u8, type_name, "MacAppIcon") != null) {
        return try alloc.dupe(u8, "MacAppIcon");
    }
    if (std.mem.indexOf(u8, type_name, "MacOSDockDropBehavior") != null) {
        return try alloc.dupe(u8, "MacOSDockDropBehavior");
    }
    if (std.mem.indexOf(u8, type_name, "GtkTabsLocation") != null) {
        return try alloc.dupe(u8, "GtkTabsLocation");
    }
    if (std.mem.indexOf(u8, type_name, "GtkSingleInstance") != null) {
        return try alloc.dupe(u8, "GtkSingleInstance");
    }
    
    // Other Config enums that remain as String for now (could be Swift enums later)
    if (std.mem.indexOf(u8, type_name, "ConfirmCloseSurface") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: never, always, ask
    }
    if (std.mem.indexOf(u8, type_name, "CustomShaderAnimation") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: fade, slide, etc.
    }
    if (std.mem.indexOf(u8, type_name, "NonNativeFullscreen") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: native, non_native
    }
    if (std.mem.indexOf(u8, type_name, "OptionAsAlt") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: left, right, both, none
    }
    if (std.mem.indexOf(u8, type_name, "WindowPaddingColor") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: background, theme, custom
    }
    if (std.mem.indexOf(u8, type_name, "WindowSubtitle") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: terminal, process, command
    }
    if (std.mem.indexOf(u8, type_name, "LinkPreviews") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: none, hover, always
    }
    if (std.mem.indexOf(u8, type_name, "OSCColorReportFormat") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: hex, rgb
    }
    if (std.mem.indexOf(u8, type_name, "WindowColorspace") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: srgb, display-p3
    }
    if (std.mem.indexOf(u8, type_name, "MacTitlebarProxyIcon") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: visible, hidden, auto
    }
    if (std.mem.indexOf(u8, type_name, "MacHidden") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: hide, minimize, quit
    }
    if (std.mem.indexOf(u8, type_name, "MacAppIconFrame") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: none, square, round
    }
    if (std.mem.indexOf(u8, type_name, "MacShortcuts") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: enabled, disabled
    }
    if (std.mem.indexOf(u8, type_name, "GtkToolbarStyle") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: icons, text, both
    }
    if (std.mem.indexOf(u8, type_name, "GtkTitlebarStyle") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: system, tabs, hidden
    }
    if (std.mem.indexOf(u8, type_name, "MouseShiftCapture") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: never, always, smart
    }
    if (std.mem.indexOf(u8, type_name, "WindowShowTabBar") != null) {
        return try alloc.dupe(u8, "String"); // Could be enum: never, single, multiple
    }
    
    // Legacy mappings for backwards compatibility
    if (std.mem.indexOf(u8, type_name, "WindowDecoration") != null) {
        return try alloc.dupe(u8, "String");
    }
    if (std.mem.indexOf(u8, type_name, "KeybindAction") != null) {
        return try alloc.dupe(u8, "String");
    }
    if (std.mem.indexOf(u8, type_name, "AltScreen") != null) {
        return try alloc.dupe(u8, "Bool");
    }
    if (std.mem.indexOf(u8, type_name, "ConfirmBeforeQuit") != null) {
        return try alloc.dupe(u8, "Bool");
    }
    if (std.mem.indexOf(u8, type_name, "MouseHideWhileTyping") != null) {
        return try alloc.dupe(u8, "Bool");
    }
    
    // Default for unknown enums - use String for safety (most config enums are string-based)
    return try alloc.dupe(u8, "String");
}

/// Handle struct types by name pattern matching  
/// Add new struct type mappings here when Config.zig introduces them
fn handleKnownStructByName(alloc: Allocator, type_name: []const u8) ![]const u8 {
    // Color types - represent as UInt32 for RGB hex values
    if (std.mem.endsWith(u8, type_name, ".Color") or std.mem.eql(u8, type_name, "Color")) {
        return try alloc.dupe(u8, "UInt32");
    }
    
    // Font style types
    if (std.mem.indexOf(u8, type_name, "FontSyntheticStyle") != null) {
        return try alloc.dupe(u8, "FontSyntheticStyle");
    }
    if (std.mem.indexOf(u8, type_name, "FontShapingBreak") != null) {
        return try alloc.dupe(u8, "FontShapingBreak");
    }
    if (std.mem.indexOf(u8, type_name, "FreetypeLoadFlags") != null) {
        return try alloc.dupe(u8, "FreetypeLoadFlags");
    }
    if (std.mem.indexOf(u8, type_name, "MetricModifier") != null) {
        return try alloc.dupe(u8, "Float");
    }
    if (std.mem.indexOf(u8, type_name, "MetricModifier") != null) {
        return try alloc.dupe(u8, "String"); // MetricModifier can be pixels or percentage
    }
    if (std.mem.indexOf(u8, type_name, "Theme") != null) {
        return try alloc.dupe(u8, "String");
    }
    
    // Keybinding types
    if (std.mem.indexOf(u8, type_name, "Keybind") != null) {
        return try alloc.dupe(u8, "String");
    }
    if (std.mem.indexOf(u8, type_name, "Key") != null) {
        return try alloc.dupe(u8, "String");
    }
    if (std.mem.indexOf(u8, type_name, "Modifier") != null) {
        return try alloc.dupe(u8, "String");
    }
    
    // Size and dimension types
    if (std.mem.indexOf(u8, type_name, "Size") != null or 
        std.mem.indexOf(u8, type_name, "Dimension") != null) {
        return try alloc.dupe(u8, "CGSize");
    }
    if (std.mem.indexOf(u8, type_name, "Point") != null or
        std.mem.indexOf(u8, type_name, "Position") != null) {
        return try alloc.dupe(u8, "CGPoint");
    }
    if (std.mem.indexOf(u8, type_name, "Rect") != null) {
        return try alloc.dupe(u8, "CGRect");
    }
    
    // Path and file types
    if (std.mem.indexOf(u8, type_name, "Path") != null or
        std.mem.indexOf(u8, type_name, "File") != null or
        std.mem.indexOf(u8, type_name, "Directory") != null) {
        return try alloc.dupe(u8, "String");
    }
    
    // Duration and time types
    if (std.mem.indexOf(u8, type_name, "Duration") != null or
        std.mem.indexOf(u8, type_name, "Time") != null or
        std.mem.indexOf(u8, type_name, "Timeout") != null) {
        return try alloc.dupe(u8, "TimeInterval");
    }
    
    // Range types
    if (std.mem.indexOf(u8, type_name, "Range") != null) {
        return try alloc.dupe(u8, "NSRange");
    }
    
    // URL types
    if (std.mem.indexOf(u8, type_name, "URL") != null or
        std.mem.indexOf(u8, type_name, "Uri") != null) {
        return try alloc.dupe(u8, "URL");
    }
    
    // Command and shell types
    if (std.mem.indexOf(u8, type_name, "Command") != null or
        std.mem.indexOf(u8, type_name, "Shell") != null or
        std.mem.indexOf(u8, type_name, "Program") != null) {
        return try alloc.dupe(u8, "String");
    }
    
    // Opacity and alpha types
    if (std.mem.indexOf(u8, type_name, "Opacity") != null or
        std.mem.indexOf(u8, type_name, "Alpha") != null) {
        return try alloc.dupe(u8, "Float");
    }
    
    // Default for unknown structs - use String as it's the most common config type
    return try alloc.dupe(u8, "String");
}

// ============================================================================
// MARK: - Tests
// ============================================================================

test "convertToSwiftName" {
    const testing = std.testing;
    const alloc = testing.allocator;

    {
        const result = try convertToSwiftName(alloc, "font_size");
        defer alloc.free(result);
        try testing.expectEqualStrings("fontSize", result);
    }

    {
        const result = try convertToSwiftName(alloc, "background-color");
        defer alloc.free(result);
        try testing.expectEqualStrings("backgroundColor", result);
    }

    {
        const result = try convertToSwiftName(alloc, "class");
        defer alloc.free(result);
        try testing.expectEqualStrings("`class`", result);
    }
}

test "isSwiftReservedKeyword" {
    try std.testing.expect(isSwiftReservedKeyword("class"));
    try std.testing.expect(isSwiftReservedKeyword("func"));
    try std.testing.expect(isSwiftReservedKeyword("var"));
    try std.testing.expect(!isSwiftReservedKeyword("fontSize"));
    try std.testing.expect(!isSwiftReservedKeyword("backgroundColor"));
}
