//! This program is used to generate Swift configuration types from the Zig
//! configuration file for Ghostty. This allows the macOS app to access
//! configuration options in a type-safe way.

const std = @import("std");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
const Config = @import("config/Config.zig");
const configpkg = @import("config.zig");

const log = std.log.scoped(.swift_config_gen);

/// Configuration for Swift code generation
const GenerationConfig = struct {
    /// Whether to add 'public' visibility modifiers to generated types
    use_public_visibility: bool = false,
};

/// Configuration fields to exclude from Swift generation (macOS-specific filtering)
const filtered_fields = std.StaticStringMap(void).initComptime(.{
    .{"class"},
    .{"x11-instance-name"},
    .{"link"}, // this is a Todo field, ignore for now
    .{"window-subtitle"},
    .{"window-show-tab-bar"},
    .{"window-titlebar-background"},
    .{"window-titlebar-foreground"},
    .{"async-backend"},
});

pub const GenerateError = error{
    OutOfMemory,
    WriteError,
    ParseError,
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer {
        const deinit_status = gpa.deinit();
        if (deinit_status == .leak) {
            log.err("memory leak detected", .{});
        }
    }
    const alloc = gpa.allocator();

    const stdout = std.io.getStdOut().writer();
    
    const config = GenerationConfig{}; // Use default config for now
    
    try generateSwiftHeader(stdout, config);
    genConfigFields(alloc, stdout, config) catch |err| {
        log.err("failed to generate config fields: {}", .{err});
        return err;
    };
    try generateSwiftFooter(stdout);
}

fn getSwiftTypeForConfigField(alloc: Allocator, field_name: []const u8) ![]const u8 {
    // Use comptime to generate a lookup for all config field types
    inline for (@typeInfo(Config).@"struct".fields) |config_field| {
        if (std.mem.eql(u8, config_field.name, field_name)) {
            return try zigTypeToSwiftType(alloc, config_field.type);
        }
    }
    
    return error.FieldNotFound;
}

fn generateSwiftHeader(writer: anytype, config: GenerationConfig) !void {
    const visibility = if (config.use_public_visibility) "public " else "";
    
    // File header
    try writer.writeAll(
        \\// THIS FILE IS AUTO GENERATED
        \\// Do not edit this file directly
        \\
        \\import Foundation
        \\
    );
    
    // FontVariation struct and extension
    try generateFontVariation(writer, visibility);
    
    try writer.writeAll("// MARK: - Configuration Enums\n\n");
    
    // Generate all enums
    try generateConfigurationEnums(writer, visibility);
    
    // Start GhosttyConfig struct
    try writer.print("/// Configuration options for Ghostty\n{s}struct GhosttyConfig {{\n\n", .{visibility});
}

fn generateFontVariation(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// Font variation axis configuration
        \\{s}struct FontVariation {{
        \\    {s}let axis: String
        \\    {s}let value: Float
        \\    
        \\    {s}init(axis: String, value: Float) {{
        \\        self.axis = axis
        \\        self.value = value
        \\    }}
        \\}}
        \\
    , .{ visibility, visibility, visibility, visibility });
    
    try writer.print(
        \\/// Common font variation axes
        \\{s}extension FontVariation {{
        \\    static func weight(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "wght", value: value)
        \\    }}
        \\    
        \\    static func slant(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "slnt", value: value)
        \\    }}
        \\    
        \\    static func italic(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "ital", value: value)
        \\    }}
        \\    
        \\    static func opticalSize(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "opsz", value: value)
        \\    }}
        \\    
        \\    static func width(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "wdth", value: value)
        \\    }}
        \\    
        \\    static func grade(_ value: Float) -> FontVariation {{
        \\        FontVariation(axis: "GRAD", value: value)
        \\    }}
        \\}}
        \\
    , .{visibility});
}

fn generateConfigurationEnums(writer: anytype, visibility: []const u8) !void {
    try generateCursorStyleEnum(writer, visibility);
    try generateFontEnums(writer, visibility);
    try generateImageEnums(writer, visibility);
    try generateInteractionEnums(writer, visibility);
    try generateRenderingEnums(writer, visibility);
    try generateFreetypeStruct(writer, visibility);
}

fn generateCursorStyleEnum(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// Cursor style for the terminal
        \\{s}enum CursorStyle: String {{
        \\    case bar = "bar"
        \\    case block = "block"
        \\    case underline = "underline"
        \\    case blockHollow = "block_hollow"
        \\}}
        \\
    , .{visibility});
}

fn generateFontEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// Font style configuration
        \\{s}enum FontStyle: String {{
        \\    case normal = "normal"
        \\    case bold = "bold"
        \\    case italic = "italic"
        \\    case boldItalic = "bold_italic"
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\/// Font synthetic style options
        \\{s}enum FontSyntheticStyle: String {{
        \\    case none = "none"
        \\    case bold = "bold"
        \\    case italic = "italic"
        \\    case all = "all"
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\/// Font shaping line break options
        \\{s}enum FontShapingBreak: String {{
        \\    case word = "word"
        \\    case anywhere = "anywhere"
        \\}}
        \\
    , .{visibility});
}

fn generateImageEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// Background image positioning
        \\{s}enum BackgroundImagePosition: String {{
        \\    case center = "center"
        \\    case topLeft = "top-left"
        \\    case topCenter = "top-center"
        \\    case topRight = "top-right"
        \\    case bottomLeft = "bottom-left"
        \\    case bottomCenter = "bottom-center"
        \\    case bottomRight = "bottom-right"
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\/// Background image fit options
        \\{s}enum BackgroundImageFit: String {{
        \\    case fill = "fill"
        \\    case contain = "contain"
        \\    case cover = "cover"
        \\    case stretch = "stretch"
        \\}}
        \\
    , .{visibility});
}

fn generateInteractionEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// Clipboard access control
        \\{s}enum ClipboardAccess: String {{
        \\    case allow = "allow"
        \\    case deny = "deny"
        \\    case ask = "ask"
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\/// Copy on select behavior
        \\{s}enum CopyOnSelect: String {{
        \\    case never = "never"
        \\    case always = "always"
        \\    case clipboard = "clipboard"
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\/// Right click action
        \\{s}enum RightClickAction: String {{
        \\    case paste = "paste"
        \\    case menu = "menu"
        \\    case none = "none"
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\/// Window theme options
        \\{s}enum WindowTheme: String {{
        \\    case auto = "auto"
        \\    case light = "light"
        \\    case dark = "dark"
        \\    case system = "system"
        \\}}
        \\
    , .{visibility});
}

fn generateRenderingEnums(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// Alpha blending style options
        \\{s}enum AlphaBlending: String {{
        \\    case straight = "straight"
        \\    case premultiplied = "premultiplied"
        \\}}
        \\
    , .{visibility});
    
    try writer.print(
        \\/// Grapheme width calculation method
        \\{s}enum GraphemeWidthMethod: String {{
        \\    case unicode = "unicode"
        \\    case legacy = "legacy"
        \\    case wezterm = "wezterm"
        \\}}
        \\
    , .{visibility});
}

fn generateFreetypeStruct(writer: anytype, visibility: []const u8) !void {
    try writer.print(
        \\/// FreeType load flags
        \\{s}struct FreetypeLoadFlags: OptionSet {{
        \\    {s}let rawValue: Int
        \\    {s}init(rawValue: Int) {{ self.rawValue = rawValue }}
        \\    
        \\    {s}static let defaultFlags: FreetypeLoadFlags = []
        \\    {s}static let noHinting = FreetypeLoadFlags(rawValue: 1 << 0)
        \\    {s}static let forceAutoHint = FreetypeLoadFlags(rawValue: 1 << 1)
        \\    {s}static let noBitmap = FreetypeLoadFlags(rawValue: 1 << 2)
        \\}}
        \\
    , .{ visibility, visibility, visibility, visibility, visibility, visibility, visibility });
}

fn generateSwiftFooter(writer: anytype) !void {
    try writer.writeAll(
        \\}
        \\
    );
}

fn genConfigFields(alloc: Allocator, writer: anytype, config: GenerationConfig) !void {
    var ast = std.zig.Ast.parse(alloc, @embedFile("config/Config.zig"), .zig) catch |err| {
        log.err("failed to parse Config.zig: {}", .{err});
        return GenerateError.ParseError;
    };
    defer ast.deinit(alloc);

    // Simple approach: generate fields individually like helpgen.zig
    // but use a smarter grouping in the Swift output
    inline for (@typeInfo(Config).@"struct".fields) |field| {
        if (field.name[0] == '_') continue;

        // Check if field is in the filtered list
        const filtered = comptime filtered_fields.has(field.name);
        if (filtered) continue;

        genConfigField(alloc, writer, ast, field, config) catch |err| {
            log.warn("failed to generate field '{s}': {}", .{ field.name, err });
        };
    }
}

fn extractFieldName(raw_name: []const u8) []const u8 {
    return if (raw_name[0] == '@') 
        raw_name[2 .. raw_name.len - 1] 
    else 
        raw_name;
}

fn findNextFieldIdentifier(tokens: []std.zig.Token.Tag, start_idx: usize) ?usize {
    var idx = start_idx;
    
    // Skip to next identifier
    while (idx < tokens.len and tokens[idx] != .identifier) {
        idx += 1;
    }
    if (idx >= tokens.len) return null;

    // Check if this identifier is preceded by a doc comment (meaning it's a new field group)
    if (idx > 0 and tokens[idx - 1] == .doc_comment) {
        return null; // This is the start of a new documentation block
    }

    // Check if this identifier is a field (followed by colon within a few tokens)
    for (idx + 1..@min(idx + 4, tokens.len)) |check_idx| {
        if (tokens[check_idx] == .colon) {
            return idx;
        }
    }
    
    // Not a field, keep searching
    return findNextFieldIdentifier(tokens, idx + 1);
}

fn generateSwiftDeclarations(alloc: Allocator, writer: anytype, fields: []const AdjacentFieldInfo, config: GenerationConfig) !void {
    var type_to_names = std.StringHashMap(std.ArrayList([]const u8)).init(alloc);
    defer {
        var iter = type_to_names.iterator();
        while (iter.next()) |entry| {
            entry.value_ptr.deinit();
        }
        type_to_names.deinit();
    }

    for (fields) |field| {
        const result = try type_to_names.getOrPut(field.swift_type);
        if (!result.found_existing) {
            result.value_ptr.* = std.ArrayList([]const u8).init(alloc);
        }
        try result.value_ptr.append(field.swift_name);
    }

    const visibility = if (config.use_public_visibility) "public " else "";
    
    var iter = type_to_names.iterator();
    while (iter.next()) |entry| {
        const type_name = entry.key_ptr.*;
        const names = entry.value_ptr.items;
        
        try writer.print("    {s}let ", .{visibility});
        for (names, 0..) |field_name, idx| {
            if (idx > 0) try writer.writeAll(", ");
            try writer.writeAll(field_name);
        }
        try writer.writeAll(": ");
        try writer.writeAll(type_name);
        try writer.writeAll("\n");
    }
    try writer.writeAll("\n");
}

fn genConfigField(
    alloc: Allocator,
    writer: anytype,
    ast: std.zig.Ast,
    comptime field: std.builtin.Type.StructField,
    config: GenerationConfig,
) !void {
    const tokens = ast.tokens.items(.tag);

    for (tokens, 0..) |token, i| {
        if (token != .identifier) continue;
        if (i == 0 or tokens[i - 1] != .doc_comment) continue;

        const name = ast.tokenSlice(@intCast(i));
        const key = extractFieldName(name);
        if (!std.mem.eql(u8, key, field.name)) continue;

        const comment = extractDocComments(alloc, ast, @intCast(i - 1), tokens) catch |err| {
            log.warn("failed to extract doc comments for field '{s}': {}", .{ field.name, err });
            return err;
        };
        defer alloc.free(comment);

        // Find all adjacent fields that share this documentation
        var adjacent_fields = std.ArrayList(AdjacentFieldInfo).init(alloc);
        defer {
            for (adjacent_fields.items) |item| {
                alloc.free(item.swift_name);
                alloc.free(item.swift_type);
            }
            adjacent_fields.deinit();
        }

        // Add the current field
        const swift_name = try convertToSwiftName(alloc, field.name);
        const swift_type = try zigTypeToSwiftType(alloc, field.type);
        try adjacent_fields.append(.{
            .swift_name = swift_name,
            .swift_type = swift_type,
        });

        // Look for adjacent fields that follow immediately after this one
        var search_idx = i + 1;
        while (search_idx < tokens.len) {
            search_idx = findNextFieldIdentifier(tokens, search_idx) orelse break;

            const next_field_name_raw = ast.tokenSlice(@intCast(search_idx));
            const next_field_name = extractFieldName(next_field_name_raw);

            // Skip private fields
            if (next_field_name[0] == '_') {
                search_idx += 1;
                continue;
            }

            // Check if this field exists in Config and get its type
            const next_swift_type = getSwiftTypeForConfigField(alloc, next_field_name) catch {
                search_idx += 1;
                continue;
            };

            const next_swift_name = try convertToSwiftName(alloc, next_field_name);
            try adjacent_fields.append(.{
                .swift_name = next_swift_name,
                .swift_type = next_swift_type,
            });

            search_idx += 1;
        }

        // Generate Swift output - group by type for adjacent declaration
        try writer.writeAll(comment);
        try generateSwiftDeclarations(alloc, writer, adjacent_fields.items, config);
        
        break;
    }
}

const AdjacentFieldInfo = struct {
    swift_name: []const u8,
    swift_type: []const u8,
};

fn extractDocComments(
    alloc: Allocator,
    ast: std.zig.Ast,
    index: std.zig.Ast.TokenIndex,
    tokens: []std.zig.Token.Tag,
) ![]const u8 {
    const start_idx: usize = start_idx: for (0..index) |i| {
        const reverse_i = index - i - 1;
        const token = tokens[reverse_i];
        if (token != .doc_comment) break :start_idx reverse_i + 1;
    } else unreachable;

    var lines = std.ArrayList([]const u8).init(alloc);
    defer lines.deinit();
    
    for (start_idx..index + 1) |i| {
        const token = tokens[i];
        if (token != .doc_comment) break;
        try lines.append(ast.tokenSlice(@intCast(i))[3..]);
    }

    var buffer = std.ArrayList(u8).init(alloc);
    errdefer buffer.deinit();
    
    const writer = buffer.writer();
    const prefix = findCommonPrefix(lines);

    try writer.writeAll("    /// ");
    for (lines.items, 0..) |line, idx| {
        if (idx > 0) try writer.writeAll("    /// ");
        try writer.writeAll(line[@min(prefix, line.len)..]);
        if (idx < lines.items.len - 1) try writer.writeAll("\n");
    }
    try writer.writeAll("\n");

    return buffer.toOwnedSlice();
}

fn findCommonPrefix(lines: std.ArrayList([]const u8)) usize {
    var m: usize = std.math.maxInt(usize);
    for (lines.items) |line| {
        var n: usize = std.math.maxInt(usize);
        for (line, 0..) |c, i| {
            if (c != ' ') {
                n = i;
                break;
            }
        }
        m = @min(m, n);
    }
    return m;
}

fn convertToSwiftName(alloc: Allocator, zig_name: []const u8) ![]const u8 {
    var result = std.ArrayList(u8).init(alloc);
    errdefer result.deinit();
    
    var capitalize_next = false;

    for (zig_name, 0..) |c, i| {
        if (c == '_' or c == '-') {
            capitalize_next = true;
        } else if (capitalize_next and i > 0) {
            try result.append(std.ascii.toUpper(c));
            capitalize_next = false;
        } else {
            try result.append(c);
        }
    }

    const camel_case_name = try result.toOwnedSlice();

    if (isSwiftReservedKeyword(camel_case_name)) {
        const wrapped = std.fmt.allocPrint(alloc, "`{s}`", .{camel_case_name}) catch |err| {
            alloc.free(camel_case_name);
            return err;
        };
        alloc.free(camel_case_name);
        return wrapped;
    }

    return camel_case_name;
}

/// Swift reserved keywords that need to be escaped with backticks
fn isSwiftReservedKeyword(name: []const u8) bool {
    const swift_keywords = [_][]const u8{
        "associatedtype", "class",       "deinit",       "enum",         "extension",   "fileprivate", "func",
        "import",         "init",        "inout",        "internal",     "let",         "open",        "operator",
        "private",        "protocol",    "public",       "static",       "struct",      "subscript",   "typealias",
        "var",            "break",       "case",         "continue",     "default",     "defer",       "do",
        "else",           "fallthrough", "for",          "guard",        "if",          "in",          "repeat",
        "return",         "switch",      "where",        "while",        "as",          "catch",       "false",
        "is",             "nil",         "rethrows",     "super",        "self",        "Self",        "throw",
        "throws",         "true",        "try",          "Any",          "Protocol",    "Type",        "associativity",
        "convenience",    "dynamic",     "didSet",       "final",        "get",         "indirect",    "infix",
        "lazy",           "left",        "mutating",     "none",         "nonmutating", "optional",    "override",
        "postfix",        "precedence",  "prefix",       "required",     "right",       "set",         "some",
        "unowned",        "weak",        "willSet",
    };

    for (swift_keywords) |keyword| {
        if (std.mem.eql(u8, name, keyword)) {
            return true;
        }
    }

    return false;
}

fn zigTypeToSwiftType(alloc: Allocator, comptime T: type) ![]const u8 {
    // Handle special Ghostty config types first
    if (T == configpkg.RepeatableFontVariation) {
        return try alloc.dupe(u8, "[FontVariation]");
    }
    if (T == configpkg.RepeatableString) {
        return try alloc.dupe(u8, "[String]");
    }
    if (T == configpkg.RepeatableCodepointMap) {
        return try alloc.dupe(u8, "[String: String]");
    }

    return switch (@typeInfo(T)) {
        .bool => try alloc.dupe(u8, "Bool"),
        .int => |info| switch (info.bits) {
            8 => try alloc.dupe(u8, if (info.signedness == .signed) "Int8" else "UInt8"),
            16 => try alloc.dupe(u8, if (info.signedness == .signed) "Int16" else "UInt16"),
            32 => try alloc.dupe(u8, if (info.signedness == .signed) "Int32" else "UInt32"),
            64 => try alloc.dupe(u8, if (info.signedness == .signed) "Int64" else "UInt64"),
            else => try alloc.dupe(u8, if (info.signedness == .signed) "Int" else "UInt"),
        },
        .float => |info| switch (info.bits) {
            32 => try alloc.dupe(u8, "Float"),
            64 => try alloc.dupe(u8, "Double"),
            else => try alloc.dupe(u8, "Double"),
        },
        .optional => |info| {
            const child_type = try zigTypeToSwiftType(alloc, info.child);
            defer alloc.free(child_type);
            return std.fmt.allocPrint(alloc, "{s}?", .{child_type});
        },
        .pointer => |info| switch (info.size) {
            .slice => {
                if (info.child == u8) {
                    return try alloc.dupe(u8, "String");
                } else {
                    const child_type = try zigTypeToSwiftType(alloc, info.child);
                    defer alloc.free(child_type);
                    return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
                }
            },
            .many => {
                if (info.child == u8) {
                    return try alloc.dupe(u8, "String");
                } else {
                    const child_type = try zigTypeToSwiftType(alloc, info.child);
                    defer alloc.free(child_type);
                    return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
                }
            },
            else => {
                const child_type = try zigTypeToSwiftType(alloc, info.child);
                defer alloc.free(child_type);
                return std.fmt.allocPrint(alloc, "UnsafePointer<{s}>", .{child_type});
            },
        },
        .array => |info| {
            if (info.child == u8) {
                return try alloc.dupe(u8, "String");
            } else {
                const child_type = try zigTypeToSwiftType(alloc, info.child);
                defer alloc.free(child_type);
                return std.fmt.allocPrint(alloc, "[{s}]", .{child_type});
            }
        },
        .@"enum" => {
            // Check if this is a known enum type by name
            const type_name = @typeName(T);
            return try handleKnownEnumByName(alloc, type_name);
        },
        .@"struct" => {
            // Check if this is a known struct type by name  
            const type_name = @typeName(T);
            return try handleKnownStructByName(alloc, type_name);
        },
        .@"union" => try alloc.dupe(u8, "Any"),
        else => try alloc.dupe(u8, "Any"),
    };
}

fn handleKnownEnumByName(alloc: Allocator, type_name: []const u8) ![]const u8 {
    // Only handle enums we explicitly know about
    if (std.mem.indexOf(u8, type_name, "CursorStyle") != null) {
        return try alloc.dupe(u8, "CursorStyle");
    }
    if (std.mem.indexOf(u8, type_name, "AlphaBlending") != null) {
        return try alloc.dupe(u8, "AlphaBlending");
    }
    if (std.mem.indexOf(u8, type_name, "GraphemeWidthMethod") != null) {
        return try alloc.dupe(u8, "GraphemeWidthMethod");
    }
    if (std.mem.indexOf(u8, type_name, "ClipboardAccess") != null) {
        return try alloc.dupe(u8, "ClipboardAccess");
    }
    if (std.mem.indexOf(u8, type_name, "CopyOnSelect") != null) {
        return try alloc.dupe(u8, "CopyOnSelect");
    }
    if (std.mem.indexOf(u8, type_name, "RightClickAction") != null) {
        return try alloc.dupe(u8, "RightClickAction");
    }
    if (std.mem.indexOf(u8, type_name, "WindowTheme") != null) {
        return try alloc.dupe(u8, "WindowTheme");
    }
    if (std.mem.indexOf(u8, type_name, "BackgroundImagePosition") != null) {
        return try alloc.dupe(u8, "BackgroundImagePosition");
    }
    if (std.mem.indexOf(u8, type_name, "BackgroundImageFit") != null) {
        return try alloc.dupe(u8, "BackgroundImageFit");
    }
    if (std.mem.indexOf(u8, type_name, "WindowDecoration") != null) {
        return try alloc.dupe(u8, "String");
    }
    if (std.mem.indexOf(u8, type_name, "KeybindAction") != null) {
        return try alloc.dupe(u8, "String");
    }
    if (std.mem.indexOf(u8, type_name, "AltScreen") != null) {
        return try alloc.dupe(u8, "Bool");
    }
    if (std.mem.indexOf(u8, type_name, "ConfirmBeforeQuit") != null) {
        return try alloc.dupe(u8, "Bool");
    }
    if (std.mem.indexOf(u8, type_name, "MouseHideWhileTyping") != null) {
        return try alloc.dupe(u8, "Bool");
    }
    
    // Default for unknown enums - use String for safety (most config enums are string-based)
    return try alloc.dupe(u8, "String");
}

fn handleKnownStructByName(alloc: Allocator, type_name: []const u8) ![]const u8 {
    // Color types - represent as UInt32 for RGB hex values
    if (std.mem.endsWith(u8, type_name, ".Color") or std.mem.eql(u8, type_name, "Color")) {
        return try alloc.dupe(u8, "UInt32");
    }
    
    // Font style types
    if (std.mem.indexOf(u8, type_name, "FontStyle") != null and 
        std.mem.indexOf(u8, type_name, "FontSyntheticStyle") == null) {
        return try alloc.dupe(u8, "FontStyle");
    }
    if (std.mem.indexOf(u8, type_name, "FontSyntheticStyle") != null) {
        return try alloc.dupe(u8, "FontSyntheticStyle");
    }
    if (std.mem.indexOf(u8, type_name, "FontShapingBreak") != null) {
        return try alloc.dupe(u8, "FontShapingBreak");
    }
    if (std.mem.indexOf(u8, type_name, "FreetypeLoadFlags") != null) {
        return try alloc.dupe(u8, "FreetypeLoadFlags");
    }
    if (std.mem.indexOf(u8, type_name, "MetricModifier") != null) {
        return try alloc.dupe(u8, "Float");
    }
    if (std.mem.indexOf(u8, type_name, "Theme") != null) {
        return try alloc.dupe(u8, "String");
    }
    
    // Keybinding types
    if (std.mem.indexOf(u8, type_name, "Keybind") != null) {
        return try alloc.dupe(u8, "String");
    }
    if (std.mem.indexOf(u8, type_name, "Key") != null) {
        return try alloc.dupe(u8, "String");
    }
    if (std.mem.indexOf(u8, type_name, "Modifier") != null) {
        return try alloc.dupe(u8, "String");
    }
    
    // Size and dimension types
    if (std.mem.indexOf(u8, type_name, "Size") != null or 
        std.mem.indexOf(u8, type_name, "Dimension") != null) {
        return try alloc.dupe(u8, "CGSize");
    }
    if (std.mem.indexOf(u8, type_name, "Point") != null or
        std.mem.indexOf(u8, type_name, "Position") != null) {
        return try alloc.dupe(u8, "CGPoint");
    }
    if (std.mem.indexOf(u8, type_name, "Rect") != null) {
        return try alloc.dupe(u8, "CGRect");
    }
    
    // Path and file types
    if (std.mem.indexOf(u8, type_name, "Path") != null or
        std.mem.indexOf(u8, type_name, "File") != null or
        std.mem.indexOf(u8, type_name, "Directory") != null) {
        return try alloc.dupe(u8, "String");
    }
    
    // Duration and time types
    if (std.mem.indexOf(u8, type_name, "Duration") != null or
        std.mem.indexOf(u8, type_name, "Time") != null or
        std.mem.indexOf(u8, type_name, "Timeout") != null) {
        return try alloc.dupe(u8, "TimeInterval");
    }
    
    // Range types
    if (std.mem.indexOf(u8, type_name, "Range") != null) {
        return try alloc.dupe(u8, "NSRange");
    }
    
    // URL types
    if (std.mem.indexOf(u8, type_name, "URL") != null or
        std.mem.indexOf(u8, type_name, "Uri") != null) {
        return try alloc.dupe(u8, "URL");
    }
    
    // Command and shell types
    if (std.mem.indexOf(u8, type_name, "Command") != null or
        std.mem.indexOf(u8, type_name, "Shell") != null or
        std.mem.indexOf(u8, type_name, "Program") != null) {
        return try alloc.dupe(u8, "String");
    }
    
    // Opacity and alpha types
    if (std.mem.indexOf(u8, type_name, "Opacity") != null or
        std.mem.indexOf(u8, type_name, "Alpha") != null) {
        return try alloc.dupe(u8, "Float");
    }
    
    // Default for unknown structs - use String as it's the most common config type
    return try alloc.dupe(u8, "String");
}

test "convertToSwiftName" {
    const testing = std.testing;
    const alloc = testing.allocator;

    {
        const result = try convertToSwiftName(alloc, "font_size");
        defer alloc.free(result);
        try testing.expectEqualStrings("fontSize", result);
    }

    {
        const result = try convertToSwiftName(alloc, "background-color");
        defer alloc.free(result);
        try testing.expectEqualStrings("backgroundColor", result);
    }

    {
        const result = try convertToSwiftName(alloc, "class");
        defer alloc.free(result);
        try testing.expectEqualStrings("`class`", result);
    }
}

test "isSwiftReservedKeyword" {
    try std.testing.expect(isSwiftReservedKeyword("class"));
    try std.testing.expect(isSwiftReservedKeyword("func"));
    try std.testing.expect(isSwiftReservedKeyword("var"));
    try std.testing.expect(!isSwiftReservedKeyword("fontSize"));
    try std.testing.expect(!isSwiftReservedKeyword("backgroundColor"));
}
